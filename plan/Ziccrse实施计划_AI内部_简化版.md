# Ziccrse 扩展实施计划（AI内部工作指南 - 简化版）

## 任务概述

**扩展名称**：Ziccrse - Cache Control Register Set Extension  
**目标**：在 sail-riscv 中实现 Ziccrse 扩展支持  
**选择理由**：
- 中等复杂度（CSR操作，类似内核开发中的寄存器操作）
- 已批准（不是实验性）
- 分配者可能未开始
- 用户有内核/CSR经验

**用户背景**：
- 有RISC-V内核开发经验（rCore、Nanos-lite）
- 熟悉CSR概念（寄存器读写、页表）
- 无Sail语言经验（需要学习）
- 无形式化验证背景（需要用通俗语言解释）

---

## 对用户的说辞（汇报用）

### 什么是Sail？

**简单解释**：Sail是一种"高级伪代码语言"

类比：
- 就像你在rCore里用Rust写内核逻辑
- Sail是用一种特殊语言写"RISC-V CPU应该怎么做"
- 它比普通伪代码更精确，可以编译成真实模拟器

**你不需要深入理解**：
- 不需要懂形式化验证
- 不需要懂类型理论
- 只需要知道"这是在描述指令的行为"

### 什么是Ziccrse？

**一句话**：控制CPU缓存的几个配置寄存器

类比：
- 就像你在rCore里操作`sstatus`、`satp`这些CSR
- Ziccrse添加了几个新的CSR，用来控制cache行为
- 比如：要不要刷新cache、用什么策略等

**和rCore的联系**：
- 你在rCore里学过Sv39页表、学过CSR
- Ziccrse就是在页表遍历时，检查这些新CSR的值
- 逻辑不复杂，就是"如果CSR的某一位是1，就做某事"

---

## 阶段划分（无时间限制）

### Phase 1: 找规范，搞清楚要做啥

**AI任务**：
1. 搜索Ziccrse规范文档
2. 确认要添加哪些CSR寄存器
3. 列出每个CSR的地址和功能

**给用户解释**：
> "我们先要找到RISC-V官方文档，看看Ziccrse定义了哪些寄存器，每个寄存器是干嘛的。就像你看RISC-V手册查`sstatus`的定义一样。"

**交付物**：
- CSR列表（地址、名称、功能）
- 规范文档链接或摘要

---

### Phase 2: 看别人的代码，学怎么写

**AI任务**：
1. 找一个已经实现的简单CSR扩展（如Ssqosid）
2. 分析代码结构：怎么定义CSR、怎么读写、怎么注册
3. 提取可复用的代码模板

**给用户解释**：
> "我们看看别人是怎么实现类似功能的。就像你在rCore里看别人的lab代码学习一样。"

**交付物**：
- 参考代码文件
- 代码模板（填空即可）

---

### Phase 3: 搭架子（注册扩展）

**AI任务**：
1. 创建扩展目录
2. 在配置文件中注册扩展（告诉系统"我支持Ziccrse"）
3. 确保能编译通过

**给用户解释**：
> "这一步就是告诉sail-riscv：'我要加一个新扩展'。就像你在rCore里新建一个module，然后在Cargo.toml里注册它。"

**交付物**：
- 目录结构
- 配置文件修改
- 编译通过

---

### Phase 4: 实现CSR读写

**AI任务**：
1. 定义CSR寄存器
2. 实现读取函数（当CPU读这个CSR时返回什么值）
3. 实现写入函数（当CPU写这个CSR时怎么保存）

**给用户解释**：
> "这一步就是实现CSR的具体逻辑。就像你在rCore里实现`sstatus`的读写一样。读的时候返回寄存器的值，写的时候更新寄存器的值。"

**关键点**：
- 某些位可能只读（写入时要屏蔽）
- 某些写入可能有副作用（如触发cache刷新）

**交付物**：
- CSR实现代码
- 简单的读写测试

---

### Phase 5: 集成到页表遍历（难点）

**AI任务**：
1. 找到页表遍历的代码
2. 在关键位置添加CSR检查
3. 根据CSR值调整cache行为

**给用户解释**：
> "这一步是把CSR用起来。在页表遍历时（就是你rCore里walk page table的地方），检查这些CSR的值，决定要不要刷新cache。"

**简化策略**：
- 如果页表集成太复杂，可以先只做CSR部分
- CSR部分本身也是一个完整的功能

**交付物**：
- 修改后的页表代码
- 或简化版本（只做CSR）

---

### Phase 6: 测试验证

**AI任务**：
1. 编译整个项目，确保无错误
2. 运行测试套件，确保没破坏现有功能
3. 创建简单测试验证新功能

**给用户解释**：
> "就像你在rCore里跑`make run`和测试一样。先确保能编译，再确保原有测试还能过，最后验证新功能。"

**交付物**：
- 测试通过报告
- 修复记录

---

### Phase 7: 提交PR

**AI任务**：
1. 准备PR描述（说明做了什么、参考了啥规范）
2. 检查代码风格
3. 提交并响应review

**给用户解释**：
> "把你的代码提交到GitHub。要写清楚你做了什么，参考了哪个RISC-V规范。就像你提交rCore作业一样，要写commit message。"

**交付物**：
- PR链接
- Review响应

---

### Phase 8: 准备技术报告

**AI任务**：
1. 帮助用户整理PPT大纲
2. 准备讲稿要点
3. 确保用户理解每个技术点（能讲出来）

**PPT结构**（30分钟）：

**1. 基础知识（5分钟）**
- 什么是RISC-V扩展（类比：就像x86的SSE、AVX指令集）
- 什么是CSR（类比：内核寄存器，如`satp`）
- 什么是Sail（类比：描述CPU行为的高级语言）

**2. 问题背景（5分钟）**
- 为什么需要Ziccrse（控制cache，优化性能）
- 应用场景（嵌入式、实时系统等需要精细控制cache）
- RISC-V规范中的定义（几个寄存器，控制什么）

**3. 思维过程（10分钟）**
- 怎么理解Ziccrse规范（看文档、查例子）
- 怎么设计实现（先搭架子、再实现CSR、最后集成）
- 怎么验证（编译、测试、跑程序）

**4. 难点（5分钟）**
- Sail语言语法不熟悉（解决了：看例子、套模板）
- 页表集成逻辑复杂（解决了：简化或分步实现）
- 调试困难（解决了：print调试、逐步验证）

**5. 解决方法（5分钟）**
- 参考现有实现（学习Ssqosid扩展）
- 分步实现（先做CSR，再做集成）
- 及时测试（每步都验证）

**交付物**：
- PPT大纲
- 讲稿要点
- Q&A准备

---

## 技术概念简化说明

### 1. Sail语言 = 高级伪代码

**复杂说法**：形式化规范语言，用于精确描述ISA语义

**简单说法**：
- 就像你在rCore里写的Rust代码，描述"如果CPU执行这条指令，就做什么事"
- 只是语法稍有不同，但逻辑是一样的

**例子对比**：

Rust（rCore）：
```rust
fn read_csr(csr: usize) -> usize {
    match csr {
        0x100 => sstatus,
        _ => panic!("unknown csr"),
    }
}
```

Sail（sail-riscv）：
```sail
function clause readCSR(0x100) = sstatus
```

**用户需要知道的**：
- Sail代码结构类似Rust
- 有函数、匹配、类型等概念
- 不需要深入理解类型系统

---

### 2. CSR扩展 = 添加寄存器

**复杂说法**：实现控制状态寄存器的读写语义

**简单说法**：
- 就像你在rCore里添加新的系统调用
- 先定义寄存器，再实现读逻辑、写逻辑

**步骤**：
1. 定义寄存器（地址、初始值）
2. 实现读（CPU读这个地址时返回什么）
3. 实现写（CPU写这个地址时怎么更新）

**用户需要知道的**：
- CSR就是内核态寄存器
- 读写逻辑和普通寄存器一样
- 可能有副作用（如写入触发刷新）

---

### 3. 页表集成 = 在walk时检查

**复杂说法**：在地址翻译流程中集成cache控制逻辑

**简单说法**：
- 就像你在rCore的`page_table.walk()`里加检查
- 检查某个CSR的值，决定是否刷新cache

**简化版本**：
```rust
// 简化逻辑
fn walk_page_table(vaddr: usize) -> Pte {
    let pte = ...; // 正常查页表
    
    // 检查Ziccrse CSR
    if ziccrse_csr.flush_bit == 1 {
        flush_cache();
    }
    
    pte
}
```

**用户需要知道的**：
- 在页表遍历的关键位置插入检查
- 根据CSR值决定行为
- 逻辑不复杂，主要是找到正确位置

---

## 汇报要点准备

### 问题预测 & 回答准备

**Q1: 什么是Sail？和普通编程语言有什么区别？**

**准备回答**：
> "Sail是一种描述CPU指令行为的高级语言。你可以把它想象成'可执行的技术文档'——它比普通伪代码更精确，可以编译成模拟器。
> 
> 和Rust/C的区别是：Sail更专注于描述'指令的语义'，而不是高效的程序。就像你写rCore是描述操作系统怎么做，Sail是描述CPU怎么做。"

**Q2: 为什么选择Ziccrse这个扩展？**

**准备回答**：
> "我选择Ziccrse是因为：
> 1. 复杂度适中——主要是CSR操作，我在rCore里有相关经验
> 2. 已批准——不是实验性扩展，符合规范
> 3. 没有重复工作——检查过没有相关PR
> 4. 有实际意义——cache控制对性能优化很重要"

**Q3: 实现过程中最大的难点是什么？**

**准备回答**：
> "最大的难点是理解Sail语言的细节。虽然逻辑上和Rust类似，但语法有些不同。我通过研究现有扩展（如Ssqosid）的代码，套用模板来解决。
> 
> 另一个难点是页表集成。我采用分步实现的方法：先确保CSR读写正确，再考虑集成到页表。"

**Q4: 你怎么验证实现的正确性？**

**准备回答**：
> "验证分三步：
> 1. 编译验证——确保代码能编译通过
> 2. 回归测试——运行现有测试套件，确保没破坏原有功能
> 3. 功能验证——创建简单测试，验证CSR读写正确"

---

## 成功标准

✅ **代码完成**：
- Ziccrse CSR完整实现
- 页表集成（或简化版本）
- 所有测试通过
- PR提交

✅ **用户能讲清楚**：
- Ziccrse是干嘛的（cache控制寄存器）
- 怎么实现的（CSR读写 + 页表集成）
- 遇到什么难点（Sail语法、集成逻辑）
- 怎么解决的（看例子、分步实现）

✅ **汇报通过**：
- PPT准备充分
- 能回答技术问题
- 展示代码和测试结果

---

## 风险与应对

### 风险1: 规范找不到
- **应对**：搜索RISC-V官方库、GitHub、询问社区
- **备选**：如果Ziccrse规范太难找，换Ziccamoa

### 风险2: 分配者已开始工作
- **应对**：观察几天，如果他push代码，立即切换
- **备选**：Ziccamoa、或者修复sail-riscv的bug

### 风险3: 页表集成太复杂
- **应对**：只做CSR部分，也算完整功能
- **解释**："我实现了Ziccrse的核心功能——CSR寄存器，页表集成可以作为后续工作"

### 风险4: 用户理解不了
- **应对**：多用类比（rCore里的对应概念）
- **解释**："这就像你在rCore里做XXX"

---

## AI行动检查清单

**每个阶段完成后检查**：
1. 代码是否编译通过
2. 用户是否理解这个阶段做了什么
3. 是否有可展示的进度
4. 是否需要调整计划

**关键决策点**：
1. 找到规范了吗？（Phase 1结束）
2. 框架能编译吗？（Phase 3结束）
3. CSR读写对吗？（Phase 4结束）
4. 要简化页表集成吗？（Phase 5决定）
5. 测试全通过了吗？（Phase 6结束）
6. PR提交了吗？（Phase 7结束）
7. 汇报准备好了吗？（Phase 8结束）

---

## 下一步行动

**立即开始**：Phase 1 - 找规范

**AI任务**：
1. 搜索Ziccrse规范
2. 确认CSR列表
3. 给用户展示"我们要做啥"

**用户任务**：
1. 看规范摘要（我准备的）
2. 确认理解任务
3. 准备开始

---

**计划状态**：准备开始 Phase 1
