(*Generated by Lem from ldconfig.lem.*)
open Lem_basic_classes
open Lem_bool
open Lem_list
open Lem_string

open Byte_sequence
open Error
open Filesystem
open Missing_pervasives

(*val read_ldconfig_paths : string -> error (list string)*)
let read_ldconfig_paths root:((string)list)error=
   (
  (* Here we assume that /etc/ld.so.conf only includes /etc/ld.so.conf.d/*.conf.
     This seems to be the case on most systems. *)
  (* TODO: parse /etc/ld.so.conf *)
  (* TODO: on FreeBSD there's /etc/libmap.conf instead *)let config_dirname = "/etc/ld.so.conf.d" in
  (* TODO: some systems have "/lib64" and "/usr/lib64" as default dirs *)
  let default_dirs = (["/usr/lib"; "/lib"]) in
  if not (Sys.file_exists (root ^ config_dirname)) then return default_dirs else bind (Filesystem_wrapper.readdir (root ^ config_dirname)) (fun filenames ->
  Error.foldM (fun acc filename1 -> bind (Byte_sequence.acquire (root ^ (config_dirname ^ ("/" ^ filename1)))) (fun bs ->
    let s = (Byte_sequence.string_of_byte_sequence bs) in
    let dirs = (List.filter (fun dir -> not (dir = "") && not ((String.get dir 0) = '#')
    ) (Ml_bindings.split_string_on_char s '\n')) in
    return ( List.rev_append (List.rev dirs) acc))
  ) default_dirs filenames))

(*val parse_runpath : string -> string -> list string*)
let parse_runpath runpath object_path:(string)list=
   (let object_dirname = (Filesystem_wrapper.dirname object_path) in
  let l = (Ml_bindings.split_string_on_char runpath ':') in
  Lem_list.map (fun p ->
    let p = (Ml_bindings.string_replace p "$ORIGIN" object_dirname) in
    let p = (Ml_bindings.string_replace p "${ORIGIN}" object_dirname) in
    (* TODO: 64-bit hardcoded *)
    let p = (Ml_bindings.string_replace p "$LIB" "lib64") in
    let p = (Ml_bindings.string_replace p "${LIB}" "lib64") in
    p
  ) l)
