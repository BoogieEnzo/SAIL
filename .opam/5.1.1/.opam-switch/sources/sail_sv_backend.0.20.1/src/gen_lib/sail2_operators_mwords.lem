open import Pervasives_extra
open import Machine_word
open import Sail2_values
open import Sail2_operators

(* Specialisation of operators to machine words *)

let inline uint v = unsignedIntegerFromWord v
let uint_maybe v = Just (uint v)

let inline sint v = signedIntegerFromWord v
let sint_maybe v = Just (sint v)

val vec_of_bits_maybe    : forall 'a. Size 'a => list (mword ty1) -> maybe (mword 'a)
val vec_of_bits_failwith : forall 'a. Size 'a => list (mword ty1) -> mword 'a
val vec_of_bits          : forall 'a. Size 'a => list (mword ty1) -> mword 'a
let vec_of_bits_maybe bits = of_bits (List.map (fun b -> bitU_of_bool (getBit b 0)) bits)
let vec_of_bits_failwith bits = of_bits_failwith (List.map (fun b -> bitU_of_bool (getBit b 0)) bits)
let vec_of_bits bits = of_bits_failwith (List.map (fun b -> bitU_of_bool (getBit b 0)) bits)

val update_vec_dec_maybe : forall 'a. Size 'a => mword 'a -> integer -> mword ty1 -> maybe (mword 'a)
val update_vec_dec       : forall 'a. Size 'a => mword 'a -> integer -> mword ty1 -> mword 'a
let update_vec_dec_maybe w i b = Just (update_mword_bool_dec w i (getBit b 0))
let update_vec_dec w i b = maybe_failwith (update_vec_dec_maybe w i b)

val update_vec_inc_maybe : forall 'a. Size 'a => mword 'a -> integer -> mword ty1 -> maybe (mword 'a)
val update_vec_inc       : forall 'a. Size 'a => mword 'a -> integer -> mword ty1 -> mword 'a
let update_vec_inc_maybe w i b = Just (update_mword_bool_inc w i (getBit b 0))
let update_vec_inc w i b = maybe_failwith (update_vec_inc_maybe w i b)

val subrange_vec_dec : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b
let subrange_vec_dec w i j = Machine_word.word_extract (nat_of_int j) (nat_of_int i) w

val subrange_vec_inc : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b
let subrange_vec_inc w i j = subrange_vec_dec w (length w - 1 - i) (length w - 1 - j)

val access_vec_inc : forall 'a. Size 'a => mword 'a -> integer -> mword ty1
let access_vec_inc w i = subrange_vec_inc w i i

val access_vec_dec : forall 'a. Size 'a => mword 'a -> integer -> mword ty1
let access_vec_dec w i = subrange_vec_dec w i i

val update_subrange_vec_dec : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b -> mword 'a
let update_subrange_vec_dec w i j w' = Machine_word.word_update w (nat_of_int j) (nat_of_int i) w'

val update_subrange_vec_inc : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b -> mword 'a
let update_subrange_vec_inc w i j w' = update_subrange_vec_dec w (length w - 1 - i) (length w - 1 - j) w'

val extz_vec : forall 'a 'b. Size 'a, Size 'b => integer -> mword 'a -> mword 'b
let extz_vec _ w = Machine_word.zeroExtend w

val exts_vec : forall 'a 'b. Size 'a, Size 'b => integer -> mword 'a -> mword 'b
let exts_vec _ w = Machine_word.signExtend w

val zero_extend : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b
let zero_extend w _ = Machine_word.zeroExtend w

val sign_extend : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b
let sign_extend w _ = Machine_word.signExtend w

val zeros : forall 'a. Size 'a => integer -> mword 'a
let zeros _ = Machine_word.wordFromNatural 0

val vector_truncate : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b
let vector_truncate w _ = Machine_word.zeroExtend w

val vector_truncateLSB : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b
let vector_truncateLSB w len =
  let len = nat_of_int len in
  let lo = Machine_word.word_length w - len in
  let hi = lo + len - 1 in
  Machine_word.word_extract lo hi w

val concat_vec : forall 'a 'b 'c. Size 'a, Size 'b, Size 'c => mword 'a -> mword 'b -> mword 'c
let concat_vec = Machine_word.word_concat

val cons_vec_bool : forall 'a 'b 'c. Size 'a, Size 'b => bool -> mword 'a -> mword 'b
let cons_vec_bool b w = wordFromBitlist (b :: bitlistFromWord w)
let cons_vec_maybe b w = Maybe.map (fun b -> cons_vec_bool b w) (bool_of_bitU b)
let cons_vec b w = maybe_failwith (cons_vec_maybe b w)

val vec_of_bool : forall 'a. Size 'a => integer -> bool -> mword 'a
let vec_of_bool _ b = wordFromBitlist [b]
let vec_of_bit_maybe len b = Maybe.map (vec_of_bool len) (bool_of_bitU b)
let vec_of_bit len b = maybe_failwith (vec_of_bit_maybe len b)

val cast_bool_vec : bool -> mword ty1
let cast_bool_vec b = vec_of_bool 1 b
let cast_unit_vec_maybe b = vec_of_bit_maybe 1 b
let cast_unit_vec b = maybe_failwith (cast_unit_vec_maybe b)

val msb : forall 'a. Size 'a => mword 'a -> bitU
let msb = most_significant

val int_of_vec : forall 'a. Size 'a => bool -> mword 'a -> integer
let int_of_vec sign w =
  if sign
  then signedIntegerFromWord w
  else unsignedIntegerFromWord w
let int_of_vec_maybe sign w = Just (int_of_vec sign w)

val string_of_bits : forall 'a. Size 'a => mword 'a -> string
let string_of_bits = string_of_bv

val string_of_bits_subrange : forall 'a. Size 'a => mword 'a -> integer -> integer -> string
let string_of_bits_subrange = string_of_bv_subrange

val decimal_string_of_bits : forall 'a. Size 'a => mword 'a -> string
let decimal_string_of_bits = decimal_string_of_bv

val and_vec : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val or_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val xor_vec : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val not_vec : forall 'a. Size 'a => mword 'a -> mword 'a
let and_vec = Machine_word.lAnd
let or_vec  = Machine_word.lOr
let xor_vec = Machine_word.lXor
let not_vec = Machine_word.lNot

val add_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val adds_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val sub_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val subs_vec  : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val mult_vec  : forall 'a 'b. Size 'a, Size 'b => mword 'a -> mword 'a -> mword 'b
val mults_vec : forall 'a 'b. Size 'a, Size 'b => mword 'a -> mword 'a -> mword 'b
let add_vec   l r = arith_op_bv integerAdd   false l r
let adds_vec  l r = arith_op_bv integerAdd   true  l r
let sub_vec   l r = arith_op_bv integerMinus false l r
let subs_vec  l r = arith_op_bv integerMinus true  l r
let mult_vec  l r = arith_op_bv integerMult  false (zeroExtend l : mword 'b) (zeroExtend r : mword 'b)
let mults_vec l r = arith_op_bv integerMult  true  (signExtend l : mword 'b) (signExtend r : mword 'b)

val add_vec_int   : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val sub_vec_int   : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val mult_vec_int  : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b
let add_vec_int   l r = arith_op_bv_int integerAdd   false l r
let sub_vec_int   l r = arith_op_bv_int integerMinus false l r
let mult_vec_int  l r = arith_op_bv_int integerMult  false (zeroExtend l : mword 'b) r

val add_int_vec   : forall 'a. Size 'a => integer -> mword 'a -> mword 'a
val sub_int_vec   : forall 'a. Size 'a => integer -> mword 'a -> mword 'a
val mult_int_vec  : forall 'a 'b. Size 'a, Size 'b => integer -> mword 'a -> mword 'b
let add_int_vec   l r = arith_op_int_bv integerAdd   false l r
let sub_int_vec   l r = arith_op_int_bv integerMinus false l r
let mult_int_vec  l r = arith_op_int_bv integerMult  false l (zeroExtend r : mword 'b)

val add_vec_bool  : forall 'a. Size 'a => mword 'a -> bool -> mword 'a
val adds_vec_bool : forall 'a. Size 'a => mword 'a -> bool -> mword 'a
val sub_vec_bool  : forall 'a. Size 'a => mword 'a -> bool -> mword 'a
val subs_vec_bool : forall 'a. Size 'a => mword 'a -> bool -> mword 'a

let add_vec_bool        l r = arith_op_bv_bool integerAdd false l r
let add_vec_bit_maybe   l r = Maybe.map (add_vec_bool l) (bool_of_bitU r)
let add_vec_bit         l r = maybe_failwith (add_vec_bit_maybe  l r)

let adds_vec_bool       l r = arith_op_bv_bool integerAdd true  l r
let adds_vec_bit_maybe  l r = Maybe.map (adds_vec_bool l) (bool_of_bitU r)
let adds_vec_bit        l r = maybe_failwith (adds_vec_bit_maybe l r)

let sub_vec_bool        l r = arith_op_bv_bool integerMinus false l r
let sub_vec_bit_maybe   l r = Maybe.map (sub_vec_bool l) (bool_of_bitU r)
let sub_vec_bit         l r = maybe_failwith (sub_vec_bit_maybe  l r)

let subs_vec_bool       l r = arith_op_bv_bool integerMinus true  l r
let subs_vec_bit_maybe  l r = Maybe.map (subs_vec_bool l) (bool_of_bitU r)
let subs_vec_bit        l r = maybe_failwith (subs_vec_bit_maybe  l r)

val shiftl       : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val shiftr       : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val arith_shiftr : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val rotl         : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val rotr         : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
let shiftl       = shiftl_mword
let shiftr       = shiftr_mword
let arith_shiftr = arith_shiftr_mword
let rotl         = rotl_mword
let rotr         = rotr_mword

val mod_vec        : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val mod_vec_maybe  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a)
let mod_vec        l r = mod_mword l r
let mod_vec_maybe  l r = mod_bv l r

val quot_vec        : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val quot_vec_maybe  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a)
let quot_vec        l r = quot_mword l r
let quot_vec_maybe  l r = quot_bv l r

val quots_vec        : forall 'a. Size 'a => mword 'a -> mword 'a -> mword 'a
val quots_vec_maybe  : forall 'a. Size 'a => mword 'a -> mword 'a -> maybe (mword 'a)
let quots_vec        l r = quots_mword l r
let quots_vec_maybe  l r = quots_bv l r

val mod_vec_int        : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val mod_vec_int_maybe  : forall 'a. Size 'a => mword 'a -> integer -> maybe (mword 'a)
let mod_vec_int        l r = mod_mword_int l r
let mod_vec_int_maybe  l r = mod_bv_int l r

val quot_vec_int        : forall 'a. Size 'a => mword 'a -> integer -> mword 'a
val quot_vec_int_maybe  : forall 'a. Size 'a => mword 'a -> integer -> maybe (mword 'a)
let quot_vec_int        l r = quot_mword_int l r
let quot_vec_int_maybe  l r = quot_bv_int l r

val replicate_bits : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> mword 'b
let replicate_bits v count = wordFromBitlist (repeat (bitlistFromWord v) count)

val duplicate_bool : forall 'a. Size 'a => bool -> integer -> mword 'a
let duplicate_bool   b n = wordFromBitlist (repeat [b] n)
let duplicate_maybe  b n = Maybe.map (fun b -> duplicate_bool b n) (bool_of_bitU b)
let duplicate        b n = maybe_failwith (duplicate_maybe b n)

val reverse_endianness : forall 'a. Size 'a => mword 'a -> mword 'a
let reverse_endianness v = wordFromBitlist (reverse_endianness_list (bitlistFromWord v))

val get_slice_int : forall 'a. Size 'a => integer -> integer -> integer -> mword 'a
let get_slice_int = get_slice_int_bv

val set_slice_int : forall 'a. Size 'a => integer -> integer -> integer -> mword 'a -> integer
let set_slice_int = set_slice_int_bv

val slice : forall 'a 'b. Size 'a, Size 'b => mword 'a -> integer -> integer -> mword 'b
let slice v lo len =
  subrange_vec_dec v (lo + len - 1) lo

val set_slice : forall 'a 'b. Size 'a, Size 'b => integer -> integer -> mword 'a -> integer -> mword 'b -> mword 'a
let set_slice (out_len:ii) (slice_len:ii) out (n:ii) v =
  update_subrange_vec_dec out (n + slice_len - 1) n v

val eq_vec    : forall 'a. Size 'a => mword 'a -> mword 'a -> bool
val neq_vec   : forall 'a. Size 'a => mword 'a -> mword 'a -> bool
let inline eq_vec    = eq_mword
let inline neq_vec   = neq_mword

val count_leading_zeros : forall 'a. Size 'a => mword 'a -> integer
let count_leading_zeros v = count_leading_zeros_bv v

val count_trailing_zeros : forall 'a. Size 'a => mword 'a -> integer
let count_trailing_zeros v = count_trailing_zeros_bv v
