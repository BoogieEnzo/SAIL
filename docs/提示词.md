你现在是本机 coding agent，请在 `/home/fengde/SAIL` 继续执行 Zabha 主线任务。目标：在尽量少人工交互下，自循环推进任务，并以“测试验收”作为阶段完成标准。

你需要每次任务完成的时候，都把docs里面需要更新的文件更新了（至少提示词md需要更新，其他的自行决定）
每一次完成任务之后commit一次，不要过于频繁也不要过于稀疏
提示词有可能过时，但如果你每次任务完成都更新提示词md，就会很新
需要sudo 我来帮你执行
如果你遇到了什么命令阻塞 我也可以帮你执行

## 0. 会话恢复（每次重启先做）
1. `cd /home/fengde/SAIL`
2. 读取并总结当前状态（禁止跳过）：
   - `docs/AGENT_STATE.json`
   - `docs/TASK_QUEUE.json`
   - `docs/RUN_LOG.md`
   - `docs/CONTEXT_BRIEF.md`（如存在）
3. 执行一次快速环境检查并记录结果（写入 `docs/RUN_LOG.md`）：
   - `command -v riscof spike sail_riscv_sim riscv64-unknown-elf-gcc || true`
   - `.venv`、`tools/spike`、`sail-riscv/build` 是否存在

## 1. 执行原则（硬性）
1. 非必要不提问：除非遇到“必须用户确认/授权/外网凭据/系统权限”才停。
2. 自循环执行：按任务队列顺序自动推进；每轮都回写状态与日志。
3. 频繁提交：每个可验证子任务完成后立即 commit，便于回滚。
4. 测试验收优先：每个阶段以测试命令或可复现检查通过作为 done 条件。
5. shell 环境是 `zsh`。

## 2. 任务状态同步规则
- 每轮任务都要同步三处：
  - `docs/AGENT_STATE.json`
  - `docs/TASK_QUEUE.json`
  - `docs/RUN_LOG.md`
- 状态值统一：`pending | in_progress | blocked | done`
- 若 blocked，必须记录：
  - 失败命令
  - 关键报错
  - 最小下一步

## 3. commit 规则（必须执行）
- 粒度：一个可验收子任务一个 commit。
- message 模板：
  - `chore(loop): ...`
  - `build(env): ...`
  - `test(riscof): ...`
  - `docs(state): ...`
- commit 前最少检查：
  - 相关脚本可执行
  - 对应验收命令已跑（成功或失败都有日志）

## 4. 当前项目快照（重启后先核对）
- 已有：
  - `riscof` 在 `.venv` 中可用
  - `spike` 目标路径：`/home/fengde/SAIL/tools/spike/bin/spike`
  - Zabha/Zacas 测试与部分配置已落地
  - `sail` 已安装到本地 opam switch：`/home/fengde/SAIL/.opam/5.1.1/bin/sail`
  - `z3` 已由系统包安装，可正常执行 `z3 --version`
  - `tools/no_ccache_bin/ccache` shim 已修复，可绕过异常 ccache 参数导致的 dune/opam 编译失败
  - `sail_riscv_sim` 已可执行，`riscof` 链路已进入可运行状态
  - 新增统一入口：`scripts/run_riscof_zabha_auto.sh`（单命令自动分阶段：phase1~phase5）
  - 阶段进度：`phase1` 与 `phase2` 已通过，`phase3` 正在执行 compat-wide sample
- 主要阻塞：
  - 本机 `riscv64-unknown-elf-gcc/binutils` 不支持 `Zabha` 指令（`amoadd.b`/`-march ... zabha` 报 unrecognized）
  - 因工具链限制，`M3-004` 的 `phase5`（full Zabha）预计 blocked；兼容子集阶段可稳定推进
  - 若外网不可用，`opam` 拉取依赖会失败
  - 若需 full Zabha 验收，需要切换到支持 Zabha 的 GNU toolchain

## 5. 默认执行顺序（继续开发时）
1. 先跑最小验收脚本（例如 `scripts/check_min.sh`）确认基线。
2. 按 `docs/TASK_QUEUE.json` 取下一个 `pending` 任务执行。
3. 执行任务对应验收命令（成功则 done，失败则 blocked+记录）。
4. 写日志、改状态、commit。
5. 进入下一任务，持续循环。

## 6. 输出要求（每轮结束）
仅输出 4 项：
1. 本轮变更文件列表（路径 + 一句话）
2. 本轮 commit hash + message
3. 任务状态变化（哪些从 pending/in_progress 变为 done/blocked）
4. 若 blocked：最多 3 条“最小人工操作步骤”

严格执行以上规则，不要只给方案，直接动手。

## 7. 2026-02-19 最新进展（自动续跑）
- 已执行：终止旧的长时间 `phase4` 运行。
- 已调整：`scripts/run_riscof_zabha_auto.sh` 将 `phase4` 拆分为 `phase4_1..phase4_4`，并在 `auto` 模式下自动衔接。
- 当前建议：继续执行同一命令 `bash /home/fengde/SAIL/scripts/run_riscof_zabha_auto.sh`，每次只跑一个 chunk，降低崩溃与长阻塞风险。
- 边界不变：`phase5` 仍依赖本机 GNU toolchain 对 Zabha 指令的支持。

## 8. 2026-02-19 自动续跑进度
- 已恢复执行并完成 `phase1`：smoke fallback 共 18 个用例，全部通过。
- 当前阶段文件：`/home/fengde/SAIL/riscv-arch-test/work-zabha/.auto_stage_state` 为 `phase1_done`。
- 下一步保持同一命令：`bash /home/fengde/SAIL/scripts/run_riscof_zabha_auto.sh`，将自动进入 `phase2`。

## 9. 2026-02-19 自动续跑进度
- `phase2` 已通过：`core_compat` 20 个用例全部通过。
- 当前阶段文件：`/home/fengde/SAIL/riscv-arch-test/work-zabha/.auto_stage_state` 为 `phase2_done`。
- 下一步继续同一命令，自动进入 `phase3`。

## 10. 2026-02-19 阶段拆分更新
- 已将 `phase5` 拆分为 `phase5_1..phase5_4`，与 `phase4` 一样支持自动续跑。
- 已做验收：`phase5_1` 在当前本机返回 blocked（exit 3），原因是本机 GNU toolchain 缺少 Zabha 指令支持。
- 主线继续：先跑完 `phase3` 与 `phase4` 分块；拿到支持 Zabha 的工具链后再继续 `phase5` 分块。

## 11. 2026-02-19 自动续跑进度
- `phase3` 已通过：`wide_compat` 选择 240 个用例，阶段完成并写入 `phase3_done`。
- 下一步自动进入 `phase4_1`（phase4 已拆成 4 个 chunk）。
- `phase5` 也已拆成 4 个 chunk，但本机仍受限于 Zabha 工具链能力。

## 12. 2026-02-19 颗粒度调整
- `phase4` 已从 4 个 chunk 调整为 12 个 chunk（每块约为原来的 1/3）。
- 目的：降低中断/崩溃时的重跑损失，缩短单次等待时间。
- 用法不变：仍只需执行 `bash /home/fengde/SAIL/scripts/run_riscof_zabha_auto.sh`，自动续跑到下一个未完成 chunk。
