# 自学笔记

- **仓库是干什么的**：本仓库（SAIL）是本地工作目录，核心目标是为 RISC-V 的 **Zabha 扩展** 在 **ACT（riscv-arch-test）** 里补测试用例，并跑通自动化验证，最终以 PR + CI 通过的形式交付。
- **为什么分这么多目录**：ACT 测试依赖“参考模型 + 模拟器 + 工具链 + 脚本”。参考模型在 `sail-riscv`，模拟器 Spike 装在 `tools/spike`，工具链在 `tools` 下，自动化流程在 `scripts`，真正要改的测试代码在子仓库 `riscv-arch-test` 里；
- **开发流程大概几步**：  
  1）在 `riscv-arch-test` 里按规范写/生成 Zabha 测试用例；  
  2）用本机脚本（`scripts/run_riscof_zabha_auto.sh`）分阶段跑：phase1～4 已跑完，phase5 需要支持 Zabha 的 gcc/汇编器；  
  3）在 GitHub 上 fork 的仓库里配好 CI（regression），PR 时以 CI 结果为准；可选配 OpenCode（见文末）。  
- **现在卡在哪**：本机 GNU 工具链不支持 Zabha 指令，phase5 全量验收跑不完；其它技术主体和阶段验证都已完成，证据在心跳文件和日志里。

---

## 0. 当前状态摘要

- **已完成**：工程推进与阶段验证的主体工作；phase1～phase4 已执行并通过。
- **未完成**：最终考核闭环——PR 提交、CI 通过、技术汇报。
- **阻塞原因**：本机 GNU 工具链（riscv64-unknown-elf-gcc/binutils）不支持 Zabha 指令编码，导致 phase5 无法完成全量汇编与验收。
- **近期进展**：fork 上 regression CI 已跑通；可选：Issue 评论 `/oc` 可触发 OpenCode（见文末）。

---

## 1. 核心概念（项目相关）

### 1.1 ACT 的定位与作用

- **定义**：`riscv-arch-test` 是 RISC-V 架构一致性测试套件，提供标准化测试用例与判定规则。
- **作用**：用于验证目标实现（模拟器或硬件）是否符合 RISC-V ISA 规范。
- **本实习任务**：为 Zabha 扩展补充测试用例及对应的预期结果与判定逻辑。

**说明**：无 ACT 覆盖时，无法对“支持 Zabha”的声明做自动化验证；有 ACT 后，可通过自动化运行得到每条指令的通过/失败结果。

**示例（ACT 测试用例形态）**：单条指令的测试通常用宏写出输入操作数与预期结果，由框架比对 DUT 输出与预期值。例如通用寄存器—寄存器运算的宏：

```c
TEST_RR_OP(andn, x30, x29, x28, 0x10000000, 0xffffffff, 0x7fffffff, x1, 4, x2)
// 含义：指令 andn，结果寄存器 x30，操作数 x29/x28，预期值 0x10000000，rs1/rs2 的值 0xffffffff/0x7fffffff
```

自动化流程会运行该用例，比较实际结果与 `0x10000000`，一致则通过。

**ACT 到底是什么？** 不是一门“写测试的语言”，而是一套**测试框架/套件**（仓库 + 规范 + 工具）：规定测试用例的**写法**（用 C 宏 + 汇编）、**目录结构**、**运行流程**，以及如何和参考模型（如 Sail）、被测目标 DUT（如 Spike）对接。你写的还是 C/汇编，只是按 ACT 的宏和规范来写；由 ACT 自带的脚本/工具把用例跑起来、比对“参考模型输出 vs DUT 输出”，给出通过/失败。所以可以理解为：**一套“怎么写、怎么跑、怎么判”的约定 + 配套工具**，不是新语言。

### 1.2 Zabha 扩展要点

- **定义**：Zabha 是 A 扩展的补充，提供字节（8-bit）与半字（16-bit）的原子内存操作。
- **原子语义**：读-改-写在同一指令内完成，中间不可被其他访问打断。
- **与普通访存区别**：需由硬件保证单条原子语义，而非多条 load/store 的软件组合。

**示例（Zabha 指令）**：Zabha 增加字节/半字原子操作，汇编中可见如下形式（本实习涉及的指令之一）：

```asm
amoadd.b  x1, x2, (x3)   /* 原子：将 (x3) 指向的字节读入，加 x2 低 8 位，写回，结果写入 x1 */
```

若工具链不支持 Zabha，在汇编或编译阶段会报“未知指令”等错误。

### 1.3 工具链阻塞原因

- **现象**：汇编/编译阶段报错，工具链无法识别 `amoadd.b` 等 Zabha 指令。
- **原因**：当前使用的 GNU 工具链版本尚未支持 Zabha 的 opcode，属于工具链能力边界，与测试设计正确性无关。
- **结论**：需使用支持 Zabha 的 riscv64-unknown-elf-gcc/binutils 方能完成 phase5 全量验证。

**示例（工具链能力检查）**：脚本中通过尝试编译一条 Zabha 指令来探测工具链是否支持 Zabha；不支持时该步失败并阻断 phase5：

```bash
# 探测命令（-march 需包含 zabha）
riscv64-unknown-elf-gcc -c -march=rv64imafd_zicsr_zabha -mabi=lp64 zabha_probe.S -o zabha_probe.o
```

若本机工具链不支持 `zabha` 扩展，上述命令会报错，phase5 不会继续执行。

### 1.4 CI 与考核关系

- **CI（持续集成）**：在代码仓库中由事件触发的自动化流水线，通常包括构建、测试、静态检查等。
- **考核依据**：考核以 CI 的客观运行结果为准，而非仅凭“本地已测过”的说明。

### 1.5 云端 CI 已跑通内容

- **触发条件**：向 `BoogieEnzo/riscv-arch-test` 的 push 触发 GitHub Actions。
- **执行内容**：按 `regress.yml` 执行完整回归：Pre-commit 检查 → QEMU 回归（rv32-max / rv64-max）、Vector Testgen、Build CTP、多配置 Sail 回归（RVA/RVB/RV20U、rv32/rv64-max 等）→ Matrix 回归 → ci_pass；整条流水线约 10 分钟，状态为 Success。
- **产出**：8 个 artifacts（各类回归日志及 ctp.html / ctp.pdf），可作为客观证据。
- **意义**：fork 上的 CI 链路已通；后续 PR 的验收将依赖该云端 CI 是否通过。

**云端跑的东西是谁定的？** 是你自己定的。官方上游仓库（如 riscv-non-isa/riscv-arch-test）并不知道你要加什么 Zabha 代码，也不会“给你建 CI”。流程是：你 **fork** 出自己仓库（如 BoogieEnzo/riscv-arch-test），在 **你自己的 fork** 里添加/修改代码和 workflow 文件（如 `.github/workflows/regress.yml`）；这些 workflow 定义的是**你的**流水线，只是跑在 **GitHub 提供的 runner 环境**上。所以：**CI 是谁的？——你仓库里写的、你定的。在哪跑？——GitHub 的云端。** 官方仓库不会替你跑你 fork 里的东西。

**示例（阶段进度证据）**本地用“心跳文件”记录当前跑到哪一阶段，便于断点续跑与汇报。例如 phase4 完成后，心跳文件内容形如：

```
done_chunks: 48/48
progress: 100%
current_or_next: phase5_1
```

对应路径：`docs/PH4_HEARTBEAT.md`；phase5 的为 `docs/PH5_HEARTBEAT.md`。

---

## 当前文件结构

```
.
├── docs                    # 报告、心跳、日志（含 docs/automation-logs）
├── riscv-arch-test         # ACT，Zabha 测试与 CI
├── sail-riscv              # 参考模型 sail_riscv_sim
├── scripts                 # 阶段化脚本
└── tools                   # spike、工具链
```

---

## 2. 汇报时可用的技术主线

1. 任务选择：为 ACT 补充 Zabha 测试，属于中等复杂度、可交付的工程任务。
2. 执行方式：采用分阶段自动化流程（phase1～phase5），而非单次手工执行。
3. 阶段进展：phase4 已完成，证据见心跳文件与阶段日志。
4. 阻塞定位：最终阶段阻塞来自工具链能力缺失，而非测试设计错误。
5. 自动化与后续：云端 regression CI 已跑通并产出 artifacts；下一步完成 phase5 与 PR CI 闭环。OpenCode 为可选，见文末。

---

## 3. 需要能说明的三个“为什么”

### 3.1 为何不属于简单改动

- 本任务属于 ISA 扩展的测试支持，涉及规范理解、用例设计、自动化脚本与证据链管理，而非文档或配置的简单修改。

### 3.2 为何 AI 参与仍体现个人能力

- 个人贡献体现在：任务边界与目标定义、验收标准制定、风险判断与结果审计；将 AI 产出转化为可交付、可复现的工程结果，本身是工程能力的一部分。

### 3.3 为何尚不能称为最终完成

- 最终完成的判定条件为：PR 已提交、CI 通过、技术汇报完成。
- 当前缺口：尚缺支持 Zabha 的工具链这一外部依赖，导致 phase5 全量验证与完整 CI 闭环未完成。

---

## 4. 后续三步

1. 获取或构建支持 Zabha 的 `riscv64-unknown-elf-gcc/binutils`，并在本机或云端完成环境配置。
2. 重新执行 phase5 全量 Zabha 验证，将结果写入日志并保留截图等证据。
3. 确认 fork 仓库的 Actions 与 Secret 已配置好后，提交 PR，等待并通过 CI。

---

## 5. 结尾表述建议

本次实习已完成技术主体与工程化验证，当前阻塞来自工具链版本对 Zabha 的支持；在完成工具链升级后，可收口至 PR 与 CI 通过，并完成考核要求。

---

## OpenCode 能做什么

- **是什么**：一个跑在 GitHub Actions 里的自动化流程；你在自己 fork 的仓库里加一个 workflow 文件（如 `.github/workflows/opencode.yml`），用第三方 Action（如 anomalyco/opencode）接上大模型 API，就可以在 Issue/PR 里用评论触发。
- **能做什么**：在 Issue 或 PR 评论里写 **`/oc`** 或 **`/opencode`** 后，workflow 会跑起来：读取当前 Issue/PR 的上下文（题目、描述、评论、代码变更等），调用配置好的大模型（如千问、Gemini），由模型根据上下文生成回复或直接改代码、提 commit、甚至开新 PR。也就是说：**用自然语言/评论驱动 AI 在你这仓库里干活**，适合“让 AI 根据 Issue 描述改代码并回评/提 PR”这类用法。
- **谁定的、在哪跑**：workflow 是你写在**自己 fork** 里的，跑在 **GitHub 提供的 runner** 上；官方上游仓库不会替你跑，也不知道你配了 OpenCode。
- **要配什么**：在 fork 的仓库 Settings → Secrets 里配置所用模型的 API Key（例如千问用 `DASHSCOPE_API_KEY`，Gemini 用 `GOOGLE_GENERATIVE_AI_API_KEY`）；若 AI 要代你改仓库内容，需在 Settings → Actions 里给 `GITHUB_TOKEN` 开 **Read and write** 权限。触发条件在 workflow 里写死（如：评论包含 `/oc` 才跑）。
