# 我的学习和汇报计划

## 任务概述

**扩展名称**：Zabha - Byte and Halfword Atomic Memory Operations  
**目标**：在 ACT (riscv-arch-test) 中为 Zabha 扩展添加测试支持  
**工作模式**：AI开发测试，我负责学习、准备汇报

---

## 里程碑划分（4个汇报点）

| 里程碑 | 内容 | 我要做什么 |
|--------|------|-----------|
| **M1** | 规范找到、ACT结构分析 | 听AI汇报，确认是否继续 |
| **M2** | 测试框架搭建、基础测试实现 | 听AI汇报，看测试代码，确认继续 |
| **M3** | 完整测试覆盖、验证通过 | 听AI汇报，确认提交PR |
| **M4** | PR已提交 | 开始学习，准备技术报告 |

---

## 各里程碑汇报内容

### M1 汇报（AI讲给我听）

**AI会汇报**：
1. 找到Zabha规范了吗？链接是什么？
2. 要实现哪些指令？功能是什么？
3. 参考了哪个扩展的代码？学到了什么？

**我需要决策**：
- ✅ 继续：进入M2
- 🔄 换方案：如果规范找不到或太复杂

---

### M2 汇报（AI讲给我听）

**AI会汇报**：
1. 创建了哪些测试文件？
2. 基础测试代码展示（1-2条指令的测试）
3. 测试能运行吗？

**我需要决策**：
- ✅ 继续：进入M3
- 📝 修改：指出问题（如有）

---

### M3 汇报（AI讲给我听）

**AI会汇报**：
1. 所有18条指令的测试都完成了吗？
2. 测试覆盖率如何？
3. 遇到什么问题？怎么解决的？

**我需要决策**：
- ✅ 继续：进入M4，准备提交PR

---

### M4 汇报（AI讲给我听）

**AI会汇报**：
1. PR链接
2. 实现总结（做了什么、参考了啥规范）
3. 学习材料已准备好

**然后**：我开始学习，准备汇报

---

## 我需要学习的内容（M4之后）

### 1. 什么是Zabha？

**一句话**：支持字节和半字（8位和16位）的原子内存操作指令

**类比rCore**：
- 就像A扩展里的AMO指令（AMOSWAP、AMOADD等）
- 但是A扩展只支持32位和64位操作
- Zabha添加了8位和16位的版本

**核心逻辑**：
- 实现对齐的内存地址的原子操作
- 支持字节(.B)和半字(.H)数据类型

---

### 2. 什么是Sail？

**一句话**：描述CPU指令行为的高级语言

**类比**：
- 就像你在rCore里用Rust写内核逻辑
- Sail是用另一种语法写"RISC-V CPU应该怎么做"

**例子对比**：

Rust（rCore）：
```rust
fn read_csr(csr: usize) -> usize {
    match csr {
        0x100 => sstatus,
        _ => panic!("unknown csr"),
    }
}
```

Sail（sail-riscv）：
```sail
function clause readCSR(0x100) = sstatus
```

**我需要知道的**：
- Sail代码结构类似Rust
- 不需要懂形式化验证
- 只需要知道"这是在描述指令的行为"

---

### 3. ACT测试是怎么编写的？

**步骤**：
1. 了解ACT测试框架结构
2. 创建测试用例定义（指令、操作数、期望结果）
3. 编写自检测试代码（RISC-V汇编）
4. 验证测试通过率

**类比rCore**：
- 就像你在rCore里写测试用例验证系统调用
- 先定义输入和期望输出，再编写测试逻辑

**具体测试内容**（18条指令）：
- AMOADD.B/H, AMOSWAP.B/H, AMOAND.B/H, AMOOR.B/H
- AMOXOR.B/H, AMOMIN.B/H, AMOMINU.B/H, AMOMAX.B/H, AMOMAXU.B/H
- 对齐和非对齐地址测试
- 边界情况测试

---

## 技术报告PPT大纲（30分钟）

### 1. 基础知识（5分钟）
- 什么是RISC-V扩展（类比x86的SSE、AVX）
- 什么是原子操作（多线程安全的关键）
- 什么是Sail（描述CPU行为的高级语言）

### 2. 问题背景（5分钟）
- 为什么需要Zabha（A扩展不支持字节/半字原子操作）
- 应用场景（嵌入式、实时系统需要细粒度原子操作）
- RISC-V规范中的定义（18条指令，支持8位和16位数据）

### 3. 思维过程（10分钟）
- 怎么理解Zabha规范（看文档、查例子）
- 怎么设计测试（参考A扩展测试、确定测试覆盖范围）
- 怎么验证（运行测试、检查覆盖率）

### 4. 难点（5分钟）
- ACT测试框架不熟悉（解决了：看文档、查例子）
- 字节和半字对齐测试设计（解决了：参考A扩展测试）
- 测试覆盖率保证（解决了：逐条指令验证）

### 5. 解决方法（5分钟）
- 参考现有测试（学习A扩展在ACT中的测试结构）
- 分步实现（先写1-2条指令的测试，再扩展全部18条）
- 及时验证（每步都运行测试确保通过）

---

## Q&A准备

**Q1: 什么是Sail？**
> Sail是一种描述CPU指令行为的高级语言。和Rust的区别是：Sail更专注于描述"指令的语义"，而不是高效的程序。

**Q2: 为什么选择为Zabha添加ACT测试？**
> 1. 复杂度适中——测试开发比核心代码实现简单，我在rCore里有测试经验
> 2. 已批准——2024年4月已批准，有独立规范文档
> 3. 无冲突——ACT缺少Zabha测试覆盖
> 4. 风险低——不修改核心代码，只添加测试
> 5. 有实际意义——完善RISC-V生态测试覆盖

**Q3: 最大难点是什么？**
> 理解Sail语言的细节。虽然逻辑和Rust类似，但语法不同。通过研究现有扩展的代码，套用模板解决。

**Q4: 怎么验证正确性？**
> 1. 测试框架验证——确保测试能正确编译和运行
> 2. 覆盖率检查——验证所有18条指令都有测试
> 3. 结果验证——验证测试输出符合预期

---

## 当前状态

**下一步**：等待M1汇报

**我的任务**：
- 听AI讲规范找到了吗
- 确认是否继续

**计划状态**：准备开始
