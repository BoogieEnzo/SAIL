# 我的学习和汇报计划

## 任务概述

**扩展名称**：Zabha - Byte and Halfword Atomic Memory Operations  
**目标**：在 sail-riscv 中实现 Zabha 扩展支持  
**工作模式**：AI实现代码，我负责学习、准备汇报

---

## 里程碑划分（4个汇报点）

| 里程碑 | 内容 | 我要做什么 |
|--------|------|-----------|
| **M1** | 规范找到、参考代码分析 | 听AI汇报，确认是否继续 |
| **M2** | 框架搭建、指令实现 | 听AI汇报，看代码，确认继续 |
| **M3** | 测试通过 | 听AI汇报，确认提交PR |
| **M4** | PR已提交 | 开始学习，准备技术报告 |

---

## 各里程碑汇报内容

### M1 汇报（AI讲给我听）

**AI会汇报**：
1. 找到Zabha规范了吗？链接是什么？
2. 要实现哪些指令？功能是什么？
3. 参考了哪个扩展的代码？学到了什么？

**我需要决策**：
- ✅ 继续：进入M2
- 🔄 换方案：如果规范找不到或太复杂

---

### M2 汇报（AI讲给我听）

**AI会汇报**：
1. 创建了哪些文件？
2. 指令实现代码展示
3. 能编译通过吗？

**我需要决策**：
- ✅ 继续：进入M3
- 📝 修改：指出问题（如有）

---

### M3 汇报（AI讲给我听）

**AI会汇报**：
1. 所有测试通过了吗？
2. 遇到什么问题？怎么解决的？

**我需要决策**：
- ✅ 继续：进入M4，准备提交PR

---

### M4 汇报（AI讲给我听）

**AI会汇报**：
1. PR链接
2. 实现总结（做了什么、参考了啥规范）
3. 学习材料已准备好

**然后**：我开始学习，准备汇报

---

## 我需要学习的内容（M4之后）

### 1. 什么是Zabha？

**一句话**：支持字节和半字（8位和16位）的原子内存操作指令

**类比rCore**：
- 就像A扩展里的AMO指令（AMOSWAP、AMOADD等）
- 但是A扩展只支持32位和64位操作
- Zabha添加了8位和16位的版本

**核心逻辑**：
- 实现对齐的内存地址的原子操作
- 支持字节(.B)和半字(.H)数据类型

---

### 2. 什么是Sail？

**一句话**：描述CPU指令行为的高级语言

**类比**：
- 就像你在rCore里用Rust写内核逻辑
- Sail是用另一种语法写"RISC-V CPU应该怎么做"

**例子对比**：

Rust（rCore）：
```rust
fn read_csr(csr: usize) -> usize {
    match csr {
        0x100 => sstatus,
        _ => panic!("unknown csr"),
    }
}
```

Sail（sail-riscv）：
```sail
function clause readCSR(0x100) = sstatus
```

**我需要知道的**：
- Sail代码结构类似Rust
- 不需要懂形式化验证
- 只需要知道"这是在描述指令的行为"

---

### 3. Zabha指令是怎么实现的？

**步骤**：
1. 定义指令类型和编码
2. 实现执行语义（原子操作逻辑）
3. 实现汇编格式
4. 注册扩展

**类比rCore**：
- 就像你在rCore里添加新的系统调用
- 先定义数据结构，再实现逻辑，最后注册

**具体指令**（16条）：
- AMOADD.B/H, AMOSWAP.B/H, AMOAND.B/H, AMOOR.B/H
- AMOXOR.B/H, AMOMIN.B/H, AMOMINU.B/H, AMOMAX.B/H, AMOMAXU.B/H

---

## 技术报告PPT大纲（30分钟）

### 1. 基础知识（5分钟）
- 什么是RISC-V扩展（类比x86的SSE、AVX）
- 什么是原子操作（多线程安全的关键）
- 什么是Sail（描述CPU行为的高级语言）

### 2. 问题背景（5分钟）
- 为什么需要Zabha（A扩展不支持字节/半字原子操作）
- 应用场景（嵌入式、实时系统需要细粒度原子操作）
- RISC-V规范中的定义（16条指令，支持8位和16位数据）

### 3. 思维过程（10分钟）
- 怎么理解Zabha规范（看文档、查例子）
- 怎么设计实现（参考A扩展和Zaamo扩展）
- 怎么验证（编译、测试、跑程序）

### 4. 难点（5分钟）
- Sail语言语法不熟悉（解决了：看例子、套模板）
- 字节和半字对齐检查（解决了：参考现有实现）
- 调试困难（解决了：print调试、逐步验证）

### 5. 解决方法（5分钟）
- 参考现有实现（学习A扩展和Zaamo扩展）
- 分步实现（先实现基本指令，再扩展全部）
- 及时测试（每步都验证）

---

## Q&A准备

**Q1: 什么是Sail？**
> Sail是一种描述CPU指令行为的高级语言。和Rust的区别是：Sail更专注于描述"指令的语义"，而不是高效的程序。

**Q2: 为什么选择Zabha？**
> 1. 复杂度适中——原子操作指令，我在rCore里有A扩展经验
> 2. 已批准——2024年4月已批准，有独立规范文档
> 3. 没有重复工作——检查过无相关PR
> 4. 有实际意义——嵌入式系统需要字节/半字原子操作

**Q3: 最大难点是什么？**
> 理解Sail语言的细节。虽然逻辑和Rust类似，但语法不同。通过研究现有扩展的代码，套用模板解决。

**Q4: 怎么验证正确性？**
> 1. 编译验证——确保能编译通过
> 2. 回归测试——确保没破坏原有功能
> 3. 功能验证——验证原子操作正确

---

## 当前状态

**下一步**：等待M1汇报

**我的任务**：
- 听AI讲规范找到了吗
- 确认是否继续

**计划状态**：准备开始
